'use strict';

// Mock models before importing services
jest.mock('../../src/models', () => ({
  Questionnaire: {
    findOne: jest.fn(),
    count: jest.fn()
  },
  Response: {
    count: jest.fn(),
    findAll: jest.fn()
  },
  Answer: {
    findAll: jest.fn(),
    count: jest.fn()
  },
  Question: {
    findAll: jest.fn()
  }
}));

const bubbleAnalyticsService = require('../../src/services/bubbleAnalyticsService');
const timeComparisonService = require('../../src/services/timeComparisonService');
const reportService = require('../../src/services/reportService');
const cacheService = require('../../src/services/cacheService');

// Get the mocked models
const { Questionnaire, Response, Answer, Question } = require('../../src/models');

describe('Analytics Service Tests', () => {
  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Bubble Analytics Service', () => {
    describe('getBubbleAnalytics', () => {
      it('should return bubble analytics for valid questionnaire', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockQuestionnaire = {
          id: questionnaireId,
          title: 'Test Questionnaire',
          categoryMapping: {
            'service': { improvementArea: 'Service Quality', weight: 1.0 },
            'product': { improvementArea: 'Product Quality', weight: 1.0 }
          }
        };

        const mockAnswers = [
          {
            ratingScore: 4.5,
            isSkipped: false,
            question: { category: 'service' },
            response: { id: 1 }
          },
          {
            ratingScore: 3.2,
            isSkipped: false,
            question: { category: 'product' },
            response: { id: 2 }
          }
        ];

        Questionnaire.findOne.mockResolvedValue(mockQuestionnaire);
        Answer.findAll.mockResolvedValue(mockAnswers);
        Response.count.mockResolvedValue(10);

        // Act
        const result = await bubbleAnalyticsService.getBubbleAnalytics(questionnaireId);

        // Assert
        expect(result).toHaveProperty('questionnaire_id', questionnaireId);
        expect(result).toHaveProperty('categories');
        expect(Array.isArray(result.categories)).toBe(true);
        expect(result.categories).toHaveLength(2);
        expect(result).toHaveProperty('period_comparison');
        expect(result).toHaveProperty('total_responses', 10);
        expect(result).toHaveProperty('response_rate');
        expect(result).toHaveProperty('generated_at');
      });

      it('should throw error for non-existent questionnaire', async () => {
        // Arrange
        const questionnaireId = 999;
        Questionnaire.findOne.mockResolvedValue(null);

        // Act & Assert
        await expect(bubbleAnalyticsService.getBubbleAnalytics(questionnaireId))
          .rejects.toThrow('not found');
      });

      it('should apply correct color coding based on ratings', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockQuestionnaire = {
          id: questionnaireId,
          categoryMapping: { 'service': { improvementArea: 'Service' } }
        };

        const mockAnswers = [
          { ratingScore: 2.0, isSkipped: false, question: { category: 'service' }, response: { id: 1 } }, // Red
          { ratingScore: 3.0, isSkipped: false, question: { category: 'service' }, response: { id: 2 } }, // Yellow
          { ratingScore: 4.5, isSkipped: false, question: { category: 'service' }, response: { id: 3 } }  // Green
        ];

        Questionnaire.findOne.mockResolvedValue(mockQuestionnaire);
        Answer.findAll.mockResolvedValue(mockAnswers);
        Response.count.mockResolvedValue(3);

        // Act
        const result = await bubbleAnalyticsService.getBubbleAnalytics(questionnaireId);

        // Assert
        expect(result.categories[0].rating).toBeCloseTo(3.17, 1); // Average of 2, 3, 4.5
        expect(result.categories[0].color).toBe('yellow'); // 3.17 is in yellow range
      });

      it('should handle empty category mapping', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockQuestionnaire = {
          id: questionnaireId,
          categoryMapping: {}
        };

        Questionnaire.findOne.mockResolvedValue(mockQuestionnaire);

        // Act & Assert
        const result = await bubbleAnalyticsService.validateQuestionnaireForBubbleAnalytics(questionnaireId);
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('ANALYTICS_ERROR_003');
      });
    });

    describe('getColorIndicator', () => {
      it('should return red for ratings <= 2.5', () => {
        expect(bubbleAnalyticsService.getColorIndicator(2.0)).toBe('red');
        expect(bubbleAnalyticsService.getColorIndicator(2.5)).toBe('red');
      });

      it('should return yellow for ratings > 2.5 and <= 3.5', () => {
        expect(bubbleAnalyticsService.getColorIndicator(2.6)).toBe('yellow');
        expect(bubbleAnalyticsService.getColorIndicator(3.5)).toBe('yellow');
      });

      it('should return green for ratings > 3.5', () => {
        expect(bubbleAnalyticsService.getColorIndicator(3.6)).toBe('green');
        expect(bubbleAnalyticsService.getColorIndicator(5.0)).toBe('green');
      });
    });

    describe('validateQuestionnaireForBubbleAnalytics', () => {
      it('should validate active questionnaire with category mapping', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockQuestionnaire = {
          id: questionnaireId,
          isActive: true,
          categoryMapping: { 'service': { improvementArea: 'Service' } }
        };

        Questionnaire.findOne.mockResolvedValue(mockQuestionnaire);

        // Act
        const result = await bubbleAnalyticsService.validateQuestionnaireForBubbleAnalytics(questionnaireId);

        // Assert
        expect(result.isValid).toBe(true);
      });

      it('should reject inactive questionnaire', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockQuestionnaire = {
          id: questionnaireId,
          isActive: false,
          categoryMapping: { 'service': { improvementArea: 'Service' } }
        };

        Questionnaire.findOne.mockResolvedValue(mockQuestionnaire);

        // Act
        const result = await bubbleAnalyticsService.validateQuestionnaireForBubbleAnalytics(questionnaireId);

        // Assert
        expect(result.isValid).toBe(false);
        expect(result.error).toBe('ANALYTICS_ERROR_002');
      });
    });
  });

  describe('Time Comparison Service', () => {
    describe('getTimePeriodComparison', () => {
      it('should generate time period comparison', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockQuestionnaire = {
          id: questionnaireId,
          categoryMapping: { 'service': { improvementArea: 'Service' } }
        };

        const mockAnswers = [
          { ratingScore: 4.0, isSkipped: false, question: { category: 'service' }, response: { id: 1 } }
        ];

        Questionnaire.findOne.mockResolvedValue(mockQuestionnaire);
        Answer.findAll.mockResolvedValue(mockAnswers);
        Response.count.mockResolvedValue(5);

        // Act
        const result = await timeComparisonService.getTimePeriodComparison(questionnaireId, {
          comparisonType: 'week_over_week'
        });

        // Assert
        expect(result).toHaveProperty('questionnaire_id', questionnaireId);
        expect(result).toHaveProperty('comparison_type', 'week_over_week');
        expect(result).toHaveProperty('current_period');
        expect(result).toHaveProperty('previous_period');
        expect(result).toHaveProperty('comparison_metrics');
        expect(result.comparison_metrics).toHaveProperty('response_count_change');
        expect(result.comparison_metrics).toHaveProperty('overall_rating_change');
        expect(result.comparison_metrics).toHaveProperty('category_comparisons');
      });

      it('should handle invalid date ranges', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockQuestionnaire = {
          id: questionnaireId,
          categoryMapping: { 'service': { improvementArea: 'Service' } }
        };

        Questionnaire.findOne.mockResolvedValue(mockQuestionnaire);

        // Act & Assert
        await expect(timeComparisonService.getTimePeriodComparison(questionnaireId, {
          comparisonType: 'custom',
          currentPeriodStart: '2025-01-01',
          currentPeriodEnd: '2024-01-01' // End before start
        })).rejects.toThrow('Invalid date range');
      });
    });

    describe('calculatePercentageChange', () => {
      it('should calculate positive percentage change', () => {
        const result = timeComparisonService.calculatePercentageChange(100, 150);
        expect(result.percentage_change).toBe(50);
        expect(result.trend).toBe('increasing');
      });

      it('should calculate negative percentage change', () => {
        const result = timeComparisonService.calculatePercentageChange(100, 75);
        expect(result.percentage_change).toBe(-25);
        expect(result.trend).toBe('decreasing');
      });

      it('should handle zero previous value', () => {
        const result = timeComparisonService.calculatePercentageChange(0, 50);
        expect(result.percentage_change).toBe(100);
        expect(result.trend).toBe('increasing');
      });
    });

    describe('determineOverallTrend', () => {
      it('should determine improving trend', () => {
        const responseChange = { trend: 'increasing' };
        const ratingChange = { trend: 'increasing' };
        const categoryComparisons = [
          { rating_trend: 'increasing' },
          { rating_trend: 'stable' }
        ];

        const trend = timeComparisonService.determineOverallTrend(
          responseChange, ratingChange, categoryComparisons
        );

        expect(trend).toBe('improving');
      });

      it('should determine declining trend', () => {
        const responseChange = { trend: 'decreasing' };
        const ratingChange = { trend: 'decreasing' };
        const categoryComparisons = [
          { rating_trend: 'decreasing' },
          { rating_trend: 'stable' }
        ];

        const trend = timeComparisonService.determineOverallTrend(
          responseChange, ratingChange, categoryComparisons
        );

        expect(trend).toBe('declining');
      });
    });
  });

  describe('Report Service', () => {
    describe('generateAnalyticsReport', () => {
      it('should generate CSV report', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockAnalytics = {
          questionnaire_id: questionnaireId,
          categories: [
            { name: 'Service', rating: 4.2, response_count: 10, color: 'green', trend: 'improving' }
          ],
          total_responses: 10,
          response_rate: 0.8,
          period_comparison: {
            current_period: '2025-10-20 to 2025-10-26',
            overall_trend: 'improving'
          },
          generated_at: new Date().toISOString()
        };

        jest.spyOn(bubbleAnalyticsService, 'getBubbleAnalytics').mockResolvedValue(mockAnalytics);

        // Act
        const result = await reportService.generateAnalyticsReport(questionnaireId, {
          format: 'csv'
        });

        // Assert
        expect(typeof result).toBe('string');
        expect(result).toContain('Analytics Report');
        expect(result).toContain('Category Analytics');
        expect(result).toContain('Service');
        expect(result).toContain('4.2');
      });

      it('should include comparison data when requested', async () => {
        // Arrange
        const questionnaireId = 1;
        const mockAnalytics = {
          questionnaire_id: questionnaireId,
          categories: [],
          total_responses: 10,
          response_rate: 0.8,
          period_comparison: { current_period: '2025-10-20 to 2025-10-26' },
          generated_at: new Date().toISOString()
        };

        const mockComparison = {
          comparison_metrics: {
            response_count_change: { current: 10, previous: 5, change: 5, percentage_change: 100, trend: 'increasing' },
            overall_rating_change: { current: 4.0, previous: 3.5, change: 0.5, percentage_change: 14.29, trend: 'increasing' },
            category_comparisons: [],
            insights: []
          }
        };

        jest.spyOn(bubbleAnalyticsService, 'getBubbleAnalytics').mockResolvedValue(mockAnalytics);
        jest.spyOn(timeComparisonService, 'getTimePeriodComparison').mockResolvedValue(mockComparison);

        // Act
        const result = await reportService.generateAnalyticsReport(questionnaireId, {
          format: 'csv',
          includeComparison: true
        });

        // Assert
        expect(result).toContain('Period Comparison');
        expect(result).toContain('Total Responses');
        expect(result).toContain('100%');
      });
    });

    describe('validateExportPermissions', () => {
      it('should allow CSV export for starter plan', () => {
        const result = reportService.validateExportPermissions('csv', 'starter');
        expect(result.allowed).toBe(true);
      });

      it('should allow Excel export for business plan', () => {
        const result = reportService.validateExportPermissions('excel', 'business');
        expect(result.allowed).toBe(true);
      });

      it('should reject any export for free plan', () => {
        const result = reportService.validateExportPermissions('csv', 'free');
        expect(result.allowed).toBe(false);
        expect(result.error).toBe('SUBSCRIPTION_ERROR_001');
      });

      it('should reject Excel export for starter plan', () => {
        const result = reportService.validateExportPermissions('excel', 'starter');
        expect(result.allowed).toBe(false);
        expect(result.error).toBe('SUBSCRIPTION_ERROR_002');
      });
    });
  });

  describe('Cache Service', () => {
    describe('setCache and getCache', () => {
      it('should set and get cache values', async () => {
        // Arrange
        const key = 'test-key';
        const value = { test: 'data' };

        // Act
        const setResult = await cacheService.setCache(key, value);
        const getResult = await cacheService.getCache(key);

        // Assert
        expect(setResult).toBe(true);
        expect(getResult).toEqual(value);
      });

      it('should return null for non-existent key', async () => {
        // Act
        const result = await cacheService.getCache('non-existent-key');

        // Assert
        expect(result).toBeNull();
      });

      it('should respect TTL', async () => {
        // Arrange
        const key = 'test-ttl-key';
        const value = { test: 'data' };
        const shortTTL = 1; // 1 second

        // Act
        await cacheService.setCache(key, value, shortTTL);
        const immediateResult = await cacheService.getCache(key);
        
        // Wait for expiration
        await new Promise(resolve => setTimeout(resolve, 1100));
        const expiredResult = await cacheService.getCache(key);

        // Assert
        expect(immediateResult).toEqual(value);
        expect(expiredResult).toBeNull();
      });
    });

    describe('cacheAnalyticsData', () => {
      it('should cache analytics data with correct key', async () => {
        // Arrange
        const questionnaireId = 1;
        const analyticsData = { categories: [] };
        const options = { dateFrom: '2025-01-01', dateTo: '2025-01-31' };

        // Act
        const result = await cacheService.cacheAnalyticsData(questionnaireId, analyticsData, options);
        const cached = await cacheService.getCachedAnalyticsData(questionnaireId, options);

        // Assert
        expect(result).toBe(true);
        expect(cached).toEqual(analyticsData);
      });
    });

    describe('invalidateQuestionnaireCache', () => {
      it('should invalidate all cache entries for questionnaire', async () => {
        // Arrange
        const questionnaireId = 1;
        
        // Set some cache entries
        await cacheService.cacheAnalyticsData(questionnaireId, { test: 'analytics' });
        await cacheService.cacheComparisonData(questionnaireId, { test: 'comparison' });

        // Verify they exist
        const analyticsBefore = await cacheService.getCachedAnalyticsData(questionnaireId);
        const comparisonBefore = await cacheService.getCachedComparisonData(questionnaireId);
        expect(analyticsBefore).not.toBeNull();
        expect(comparisonBefore).not.toBeNull();

        // Act
        const result = await cacheService.invalidateQuestionnaireCache(questionnaireId);

        // Assert
        expect(result).toBe(true);
        const analyticsAfter = await cacheService.getCachedAnalyticsData(questionnaireId);
        const comparisonAfter = await cacheService.getCachedComparisonData(questionnaireId);
        expect(analyticsAfter).toBeNull();
        expect(comparisonAfter).toBeNull();
      });
    });

    describe('healthCheck', () => {
      it('should return healthy status', async () => {
        // Act
        const result = await cacheService.healthCheck();

        // Assert
        expect(result).toHaveProperty('status', 'healthy');
        expect(result).toHaveProperty('type');
        expect(result).toHaveProperty('responseTime');
      });
    });
  });
});